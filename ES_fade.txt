//@version=5
strategy(
     "ES Professional Fade v2.4 (Execution Gap Modeled)",
     overlay=true,
     initial_capital=50000,
     default_qty_value=1,
     commission_type=strategy.commission.cash_per_contract,
     commission_value=2.01
)

// ─────────────────────────────────────────────
// Backtest Window
// ─────────────────────────────────────────────
start_date = input.time(timestamp("2025-10-01 00:00"), "Backtest Start Date")
end_date   = input.time(timestamp("2026-01-08 23:59"), "Backtest End Date")
in_date_range = time >= start_date and time <= end_date

// ─────────────────────────────────────────────
// Strategy Inputs
// ─────────────────────────────────────────────
gap_min_pct    = input.float(0.20, "Min Gap %", step=0.05) / 100
or_length      = input.int(15, "Opening Range (Min)", options=[5, 15, 30])

tick_filter    = input.int(700, "Breadth Filter ($TICK extreme)")
tick_lookback  = input.int(5, "TICK veto lookback (bars)", minval=3)
tick_need      = input.int(3, "TICK veto count", minval=2)

max_hold_bars  = input.int(24, "Max Hold (Bars, 5m)")
max_trades_day = input.int(2, "Max Trades Per Day")

// ─────────────────────────────────────────────
// Volatility Filter (ATR)
// ─────────────────────────────────────────────
use_atr_filter = input.bool(true, "Use ATR gap filter")
atr_len        = input.int(14, "ATR Length (chart TF)", minval=5)
gap_atr_mult   = input.float(1.0, "Min Gap in ATRs", step=0.25)
min_gap_pts    = input.float(1.0, "Min Gap Points", step=0.25)
atr_tf         = ta.atr(atr_len)

// ─────────────────────────────────────────────
// Execution Gap / Slippage Model
// ─────────────────────────────────────────────
use_exec_penalty = input.bool(true, "Apply execution penalty near open")
exec_window_mins = input.int(30, "Penalty window after open (mins)", minval=5)
exec_penalty_pts = input.float(0.50, "Execution penalty (ES points)", step=0.25)

// ─────────────────────────────────────────────
// Session Logic
// ─────────────────────────────────────────────
is_rth       = not na(time(timeframe.period, "0930-1600:1234567", "America/New_York"))
is_first_bar = is_rth and not is_rth[1]

// ─────────────────────────────────────────────
// State
// ─────────────────────────────────────────────
var float rth_close = na
var float rth_open  = na
var int   rth_open_time = na

var float onh = na
var float onl = na

var float or_high = na
var float or_low  = na
var bool  or_frozen = false

var int trades_today = 0
var int entry_bar = na

// ─────────────────────────────────────────────
// Prior RTH Close + Overnight Range
// ─────────────────────────────────────────────
if not is_rth and is_rth[1]
    rth_close := close[1]
    onh := high
    onl := low

if not is_rth
    onh := math.max(high, nz(onh, high))
    onl := math.min(low,  nz(onl, low))

// ─────────────────────────────────────────────
// RTH Open Reset
// ─────────────────────────────────────────────
if is_first_bar
    rth_open := open
    rth_open_time := time
    or_high := high
    or_low  := low
    or_frozen := false
    trades_today := 0

// ─────────────────────────────────────────────
// Opening Range Build
// ─────────────────────────────────────────────
bars_in_or = math.max(1, math.ceil(or_length / timeframe.multiplier))
if is_rth and not or_frozen
    if ta.barssince(is_first_bar) < bars_in_or
        or_high := math.max(high, nz(or_high, high))
        or_low  := math.min(low,  nz(or_low,  low))
    else
        or_frozen := true

// ─────────────────────────────────────────────
// Gap + ATR Filter
// ─────────────────────────────────────────────
gap_points = not na(rth_open) and not na(rth_close) ? math.abs(rth_open - rth_close) : na
gap_big_enough =
     not use_atr_filter ? true :
     (not na(gap_points) and gap_points >= min_gap_pts and gap_points >= gap_atr_mult * atr_tf)

gap_size = not na(rth_open) and not na(rth_close) ? (rth_open - rth_close) / rth_close : na
valid_gap_up = gap_size >  gap_min_pct and gap_big_enough
valid_gap_dn = gap_size < -gap_min_pct and gap_big_enough

// ─────────────────────────────────────────────
// $TICK Veto
// ─────────────────────────────────────────────
tick_val = request.security("NYSE:TICK", timeframe.period, close)
tick_ext_up = ta.sum(tick_val >  tick_filter ? 1 : 0, tick_lookback) >= tick_need
tick_ext_dn = ta.sum(tick_val < -tick_filter ? 1 : 0, tick_lookback) >= tick_need

// ─────────────────────────────────────────────
// Failure Logic
// ─────────────────────────────────────────────
failed_onh = high > onh and close < onh
failed_onl = low  < onl and close > onl

// ─────────────────────────────────────────────
// Execution Penalty Window
// ─────────────────────────────────────────────
mins_since_open = not na(rth_open_time) ? (time - rth_open_time) / 60000.0 : na
in_exec_window  = is_rth and not na(mins_since_open) and mins_since_open <= exec_window_mins
penalty = (use_exec_penalty and in_exec_window) ? exec_penalty_pts : 0.0

short_entry_price = or_low  - penalty
long_entry_price  = or_high + penalty

// ─────────────────────────────────────────────
// Trade Gate
// ─────────────────────────────────────────────
can_trade = is_rth and in_date_range and or_frozen and trades_today < max_trades_day

// ─────────────────────────────────────────────
// Entries (STOP orders with penalty)
// ─────────────────────────────────────────────
if can_trade and strategy.position_size == 0
    if valid_gap_up and failed_onh and not tick_ext_up
        strategy.entry("FadeShort", strategy.short, stop=short_entry_price)

    if valid_gap_dn and failed_onl and not tick_ext_dn
        strategy.entry("FadeLong", strategy.long, stop=long_entry_price)

// ─────────────────────────────────────────────
// Detect actual fill (important)
// ─────────────────────────────────────────────
if strategy.position_size != 0 and strategy.position_size[1] == 0
    entry_bar := bar_index
    trades_today += 1

// ─────────────────────────────────────────────
// Exits
// ─────────────────────────────────────────────
if strategy.position_size != 0
    // Conservative target adjustment during exec window
    tp_price = rth_close
    if use_exec_penalty and in_exec_window
        tp_price := strategy.position_size > 0 ? (rth_close - penalty) : (rth_close + penalty)

    stop_price = strategy.position_size > 0 ? onl : onh
    strategy.exit("TP/SL", limit=tp_price, stop=stop_price)

    if not na(entry_bar) and (bar_index - entry_bar) >= max_hold_bars
        strategy.close_all(comment="Time Out")

// ─────────────────────────────────────────────
// Cleanup
// ─────────────────────────────────────────────
if strategy.position_size == 0
    entry_bar := na

if not is_rth
    strategy.close_all(comment="EOD")
