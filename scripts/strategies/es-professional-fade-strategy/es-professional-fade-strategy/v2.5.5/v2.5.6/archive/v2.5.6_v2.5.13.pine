//@version=5
// =============================================================================
// STRATEGY: ES Professional Fade Strategy
// FILENAME: v2.5.6_v2.5.13.pine
// Version: v2.5.13
// DATE:     2026-01-09
// =============================================================================
// CHANGE LOG:
//   v2.5.13 - debugged, and reverted to Pine v5. 
//
//   STRENGTHS: [To be documented]
//   WEAKNESSES: [To be documented]
// =============================================================================
strategy("ES Professional Fade v2.5.4 (FIXED)", overlay=true, initial_capital=50000, default_qty_value=1, commission_type=strategy.commission.cash_per_contract, commission_value=2.01)

// ————— Constants
float MILLISECONDS_PER_MINUTE = 60000.0
int OR_LENGTH_5MIN = 5
int OR_LENGTH_15MIN = 15
int OR_LENGTH_30MIN = 30
int DEFAULT_TICK_FILTER = 700
int DEFAULT_TICK_LOOKBACK = 5
int DEFAULT_TICK_VETO_COUNT = 3
int DEFAULT_MAX_HOLD_BARS = 24
int DEFAULT_MAX_TRADES_DAY = 2
int DEFAULT_ATR_LENGTH = 14
float DEFAULT_GAP_ATR_MULT = 1.0
float DEFAULT_MIN_GAP_POINTS = 1.0
int DEFAULT_EXEC_WINDOW = 30
float DEFAULT_EXEC_PENALTY = 0.50
string RTH_SESSION = "0930-1600:1234567"
string TIMEZONE = "America/New_York"
string ENTRY_SHORT_ID = "FadeShort"
string ENTRY_LONG_ID = "FadeLong"
string EXIT_ID = "TP/SL"
string EXIT_TIMEOUT_COMMENT = "Time Out"
string EXIT_EOD_COMMENT = "EOD"

// ————— Inputs
int startDateInput = input.time(timestamp("2025-10-01 00:00"), "Backtest Start Date")
int endDateInput = input.time(timestamp("2026-01-08 23:59"), "Backtest End Date")
float gapMinPctInput = input.float(0.20, "Min Gap %", step=0.05)
int openingRangeLengthInput = input.int(OR_LENGTH_15MIN, "Opening Range (Min)", options=[OR_LENGTH_5MIN, OR_LENGTH_15MIN, OR_LENGTH_30MIN])
int tickFilterInput = input.int(DEFAULT_TICK_FILTER, "Breadth Filter (TICK extreme)")
int tickLookbackInput = input.int(DEFAULT_TICK_LOOKBACK, "TICK veto lookback (bars)", minval=3)
int tickVetoCountInput = input.int(DEFAULT_TICK_VETO_COUNT, "TICK veto count", minval=2)
int maxHoldBarsInput = input.int(DEFAULT_MAX_HOLD_BARS, "Max Hold (Bars, 5m)")
int maxTradesDayInput = input.int(DEFAULT_MAX_TRADES_DAY, "Max Trades Per Day")
bool useAtrFilterInput = input.bool(true, "Use ATR gap filter")
int atrLengthInput = input.int(DEFAULT_ATR_LENGTH, "ATR Length (chart TF)", minval=5)
float gapAtrMultInput = input.float(DEFAULT_GAP_ATR_MULT, "Min Gap in ATRs", step=0.25)
float minGapPointsInput = input.float(DEFAULT_MIN_GAP_POINTS, "Min Gap Points", step=0.25)
bool useExecPenaltyInput = input.bool(true, "Apply execution penalty near open")
int execWindowMinsInput = input.int(DEFAULT_EXEC_WINDOW, "Penalty window after open (mins)", minval=5)
float execPenaltyPointsInput = input.float(DEFAULT_EXEC_PENALTY, "Execution penalty (ES points)", step=0.25)

// ————— Calculations & Logic Variables
bool inDateRange = time >= startDateInput and time <= endDateInput
bool isRth = not na(time(timeframe.period, RTH_SESSION, TIMEZONE))
bool isFirstBar = isRth and not isRth[1]
float atrValue = ta.atr(atrLengthInput)

var float rthClosePrev = na
var float rthOpenCurrent = na
var int rthOpenTime = na
var float overnightHigh = na
var float overnightLow = na
var float openingRangeHigh = na
var float openingRangeLow = na
var bool openingRangeFrozen = false
var int tradesToday = 0
var int entryBarIndex = na

// Reset logic and Overnight session tracking
if not isRth and isRth[1]
    rthClosePrev := close[1]
    overnightHigh := high
    overnightLow := low

if not isRth
    overnightHigh := math.max(high, nz(overnightHigh, high))
    overnightLow := math.min(low, nz(overnightLow, low))

if isFirstBar
    rthOpenCurrent := open
    rthOpenTime := time
    openingRangeHigh := high
    openingRangeLow := low
    openingRangeFrozen := false
    tradesToday := 0

// ————— GLOBAL CALCULATIONS —————
int barsInOpeningRange = math.max(1, math.ceil(openingRangeLengthInput / timeframe.multiplier))
int barsSinceFirstBar = ta.barssince(isFirstBar)

float gapPoints = (not na(rthOpenCurrent) and not na(rthClosePrev)) ? math.abs(rthOpenCurrent - rthClosePrev) : na

bool gapBigEnough = not useAtrFilterInput ? true : (not na(gapPoints) and gapPoints >= minGapPointsInput and gapPoints >= gapAtrMultInput * atrValue)

float gapSizePct = (not na(rthOpenCurrent) and not na(rthClosePrev)) ? ((rthOpenCurrent - rthClosePrev) / rthClosePrev) : na

float gapMinPctDecimal = gapMinPctInput / 100
bool validGapUp = gapSizePct > gapMinPctDecimal and gapBigEnough
bool validGapDown = gapSizePct < -gapMinPctDecimal and gapBigEnough

// ————— TICK and Breadth Logic —————
// NOTE: We use ta.sma * length to bypass any 'ta.sum' namespace errors
// Try "TICK" (Total NYSE) or "USI:TICK" (TV's internal index)
float tickValue = request.security("TICK", timeframe.period, close, barmerge.gaps_off, barmerge.lookahead_off)

float tickUpSeries = tickValue > tickFilterInput ? 1.0 : 0.0
float tickDownSeries = tickValue < -tickFilterInput ? 1.0 : 0.0

bool tickExtremeUp = (ta.sma(tickUpSeries, tickLookbackInput) * tickLookbackInput) >= tickVetoCountInput
bool tickExtremeDown = (ta.sma(tickDownSeries, tickLookbackInput) * tickLookbackInput) >= tickVetoCountInput

bool failedOvernightHigh = high > overnightHigh and close < overnightHigh
bool failedOvernightLow = low < overnightLow and close > overnightLow

float minutesSinceOpen = not na(rthOpenTime) ? ((time - rthOpenTime) / MILLISECONDS_PER_MINUTE) : na

bool inExecWindow = isRth and not na(minutesSinceOpen) and minutesSinceOpen <= execWindowMinsInput
float execPenalty = (useExecPenaltyInput and inExecWindow) ? execPenaltyPointsInput : 0.0

float shortEntryPrice = openingRangeLow - execPenalty
float longEntryPrice = openingRangeHigh + execPenalty

bool canTrade = isRth and inDateRange and openingRangeFrozen and tradesToday < maxTradesDayInput

// ————— Opening Range Logic —————
if isRth and not openingRangeFrozen
    if barsSinceFirstBar < barsInOpeningRange
        openingRangeHigh := math.max(high, nz(openingRangeHigh, high))
        openingRangeLow := math.min(low, nz(openingRangeLow, low))
    else
        openingRangeFrozen := true

// ————— Strategy Entries —————
if canTrade and strategy.position_size == 0
    if validGapUp and failedOvernightHigh and not tickExtremeUp
        strategy.entry(ENTRY_SHORT_ID, strategy.short, stop=shortEntryPrice)
  
    if validGapDown and failedOvernightLow and not tickExtremeDown
        strategy.entry(ENTRY_LONG_ID, strategy.long, stop=longEntryPrice)

// ————— Trade Tracking —————
if strategy.position_size != 0 and strategy.position_size[1] == 0
    entryBarIndex := bar_index
    tradesToday += 1

// ————— Strategy Exits —————
if strategy.position_size != 0
    float targetPrice = rthClosePrev
    
    if useExecPenaltyInput and inExecWindow
        targetPrice := strategy.position_size > 0 ? (rthClosePrev - execPenalty) : (rthClosePrev + execPenalty)
  
    float stopPrice = strategy.position_size > 0 ? overnightLow : overnightHigh
    strategy.exit(EXIT_ID, limit=targetPrice, stop=stopPrice)
  
    if not na(entryBarIndex) and (bar_index - entryBarIndex) >= maxHoldBarsInput
        strategy.close_all(comment=EXIT_TIMEOUT_COMMENT)

if strategy.position_size == 0
    entryBarIndex := na

if not isRth
    strategy.close_all(comment=EXIT_EOD_COMMENT)